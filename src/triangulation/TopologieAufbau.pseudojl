# ==============================================================================
# BLAUPAUSE: TopologieAufbau (Phase 1 & 2: Initialisierung & Vernetzung)
# ==============================================================================
# Dieses Modul beschreibt den Aufbau des Gitters und die topologische Verknüpfung.
# Es bereitet die Datenstruktur vor, auf der später die Analyse stattfindet.

module TopologieAufbau

using ..Grid          # Geometrie: Definition des Suchraums
using ..TopicalStructure # Speicher: Verwaltung von Vertices und Simplizes
using ..Kuhn          # Algorithmus: Kuhn-Triangulation für die Vernetzung

export initialisiere_welt!

"""
    initialisiere_welt!(tm, grid, f; pruning=true)

PHASE 1 (Besiedlung): 
    Erzeugt Vertices für alle Gitterpunkte und evaluiert die Zielfunktion.
PHASE 2 (Vernetzung): 
    Verknüpft die Punkte zu Simplizes (Kuhn-Triangulation) und identifiziert 
    Kandidatenregionen für die spätere Analyse.
"""
function initialisiere_welt!(tm, grid::GridStructure, f::Function; pruning=true)
    
    # --- PHASE 1: DIE BESIEDLUNG (Geometrie -> Topologie) ---
    # Wir wandern durch das Gitter und erstellen die physischen Repräsentanten
    fuer jede zelle_id in Gitter(grid) mache:
        
        # 1.1 Position bestimmen
        pos = hole_pos(grid, zelle_id)
        
        # 1.2 "Realität" prüfen (Zielfunktion auswerten)
        # Hinweis: Hier entscheidet 'Eager Evaluation' über die Datendichte
        wert, grad = evaluiere_f(f, pos)
        
        # 1.3 Registrierung im TopicalManager
        v = registriere_vertex!(tm, zelle_id, pos, wert, grad)
        
        # 1.4 Potenzielle Minima (Sterne) für Phase 3 vormerken
        if ist_lokal_vielversprechend(v):
            werfe_in_den_work_heap!(tm, v.id, wert)
        ende
    ende
    
    # --- PHASE 2: DIE VERNETZUNG (Topologie -> Graphenstruktur) ---
    # Kuhn-Triangulation verbindet die losen Vertices zu einem geschlossenen Komplex
    fuer jede zelle_im_gitter mache:
        
        # Kuhn nutzt das Gradienten-Pruning, um irrelevante Simplizes 
        # (die sicher kein Minimum enthalten) direkt zu verwerfen.
        Kuhn.generiere_simplizes!(tm, grid, zelle_im_gitter, use_pruning=pruning)
        
    ende

    return tm # Die Welt ist nun besiedelt und vernetzt (Bereit für Phase 3)
end

end # module